import os
import re
import sys
from typing import Union

import pefile
from capstone import *
from util.info import MAIN_DIR


def disassemble_exe(path: str) -> list:
    """
    Read and disassemble exe file using 'pefile' library.

    Params
    ------
    - path(str): exe file path.

    Returns
    -------
    - list of byte: disassembled result.
    """

    if not os.path.isfile(path):
        print(f"There is not such file : '{path}'", file=sys.stderr)
        raise ValueError

    # open using pefile
    pe_data = pefile.PE(path)
    f = re.compile(pattern=".text")

    tmp = []
    output = []
    with open(path, "rb") as file:
        for sec in pe_data.sections:
            if f.search(sec.Name.decode("utf-8")):
                for _ in range((sec.SizeOfRawData - 16) // 0x40):
                    tmp.extend([hex(i) for i in file.read(0x10)])
                output.extend(
                    [code if len(code) == 4 else code + "0" for code in tmp[1:-5]]
                )

    return output


def change_to_bytes(code: Union[bytes, str, list]):
    if type(code) == list:
        code = " ".join(code)
    if type(code) != bytes:
        code = code.lower()
        code = bytes(code, "utf-8")

    return code


def byte_to_opcodes_capstone(code: Union[bytes, str, list], mode: int = 32) -> list:
    """
    Change byte opcode to string opcode using library 'capstone'

    Params
    ------
    - code(bytes | str | list) : Codes to change.
        - This type should be bytes, string or 1d-array.
        - Example : '0x8d 0x5 0xf9 0x3d 0x3 0x0 0xc3 0xcc 0xcc 0xcc 0xcc 0xcc 0xcc 0xcc 0xcc 0x48 0x89 0x54 0x24'
    - mode(int) : Bit mode in x86. Avaliable values are 32 or 64.

    Returns
    -------
    - list : Sequence of string opcode(string list)
    """

    code = change_to_bytes(code)

    if mode == 32:
        md = Cs(CS_ARCH_X86, CS_MODE_32)
    elif mode == 64:
        md = Cs(CS_ARCH_X86, CS_MODE_64)
    else:
        print("Invalid mode", file=sys.stderr)
        exit(-1)

    return [mnemonic for (_, _, mnemonic, _) in md.disasm_lite(code, 0x1000)]


def byte_to_opcodes_naive(code: list) -> list:
    # read opcode mapped information.
    instructions = dict()
    with open(f"{MAIN_DIR}/data/opcode_map.txt", "r") as file:
        lines = [line.strip().split() for line in file.readlines()]
        instructions = dict((x, y) for x, y in lines)

    return [instructions[c] if c in instructions else "" for c in code]
